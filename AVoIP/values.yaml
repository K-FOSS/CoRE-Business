asterisk:
  rtp:
    min: 10000
    max: 10100

freeswitch:
  rtp:
    min: 11000
    max: 11050

jitsi-meet:
  # Default values for jitsi-meet.
  # This is a YAML-formatted file.
  # Declare variables to be passed into your templates.

  global:
    podLabels: {}
    podAnnotations: {}
  imagePullSecrets: []

  nameOverride: ""
  fullnameOverride: ""

  enableAuth: false
  enableGuests: true
  publicURL: https://meet.mylogin.space

  tz: America/Winnipeg

  image:
    pullPolicy: IfNotPresent

  web:
    replicaCount: 0

    extraVolumeMounts:
      - name: extra-config
        subPath: custom-config.js
        mountPath: /config/custom-config.js

    extraVolumes:
      - name: extra-config
        configMap:
          name: business-avoip-jitsiweb-config

    image:
      repository: jitsi/web
      tag: stable-7648-1

    extraEnvs:
      ENABLE_TRANSCRIPTIONS: 'true'
      DESKTOP_SHARING_FRAMERATE_MIN: '15'
      DESKTOP_SHARING_FRAMERATE_MAX: '120'
      RESOLUTION: '2560'
      RESOLUTION_MIN: '720'
      RESOLUTION_WIDTH: '1440'
      RESOLUTION_WIDTH_MIN: '1280'
      ENABLE_MULTI_STREAM: 'true'

    service:
      type: ClusterIP
      port: 80
      externalIPs: []

    ingress:
      enabled: false

    # Useful for ingresses that don't support http-to-https redirect by themself, (namely: GKE),
    httpRedirect: false

    # When tls-termination by the ingress is not wanted, enable this and set web.service.type=Loadbalancer
    httpsEnabled: false

    ## Resolver IP for nginx.
    ## Set this to ClusterIP of your `kube-dns` service
    ## when using websockets and discovering JVB's address
    ## via k8s services.
    resolverIP: 10.0.8.10

    podLabels: {}
    podAnnotations: {}
    podSecurityContext: {}
      # fsGroup: 2000

    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000

    resources: {}
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    nodeSelector: {}

    tolerations: []

    affinity: {}

  jicofo:
    replicaCount: 0
    image:
      repository: jitsi/jicofo
      tag: stable

    xmpp:
      user: focus
      password: s3cr37
      componentSecret: s3cr37

    livenessProbe:
      tcpSocket:
        port: 8888

    readinessProbe:
      tcpSocket:
        port: 8888

    podLabels: {}
    podAnnotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    extraEnvs: {}

  jvb:
    replicaCount: 0
    image:
      repository: jitsi/jvb
      tag: stable

    xmpp:
      user: jvb
      password: s3cr37

    stunServers: 'nat.ipaddr.network:3478'


    useHostPort: false

    UDPPort: 10000

    service:
      enabled: true
      type: ClusterIP
      externalIPs:
        - 66.165.222.101
      ## Annotations to be added to the service (if LoadBalancer is used)
      ##
      annotations: {}

    breweryMuc: jvbbrewery

    livenessProbe: {}

    readinessProbe: {}

    podLabels: {}
    podAnnotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}

    publicIP: 66.165.222.101
    extraEnvs: {}

    websockets:
      ## Set to 'true' to enable Colibri WebSocket support in JVB:
      enabled: true
      ## Uncomment this to set JVB server ID manually,
      ## Or use one of pre-defined values:
      ## * "podIP" will fetch JVB pod's IP address from K8s metadata;
      ## * "service" will use JVB service name generated by Helm.
      ##
      ## Don't forget to set `web.resolverIP` to your cluster's
      ## DNS service IP when setting this to "service"!
      ##
      ## (default is "podIP")
      serverID: service

    metrics:
      enabled: false
      prometheusAnnotations: false
      image:
        repository: docker.io/systemli/prometheus-jitsi-meet-exporter
        tag: 1.1.9
        pullPolicy: IfNotPresent
      serviceMonitor:
        enabled: true
        selector:
          release: prometheus-operator
        interval: 10s
        # honorLabels: false

      resources:
        requests:
          cpu: 10m
          memory: 16Mi
        limits:
          cpu: 20m
          memory: 32Mi
    
  octo:
    enabled: false


  jibri:
    ## Enabling Jibri will allow users to record
    ## and/or stream their meetings (e.g. to YouTube).
    enabled: false

    ## Enable persistent storage for local recordings.
    ## If disabled, jibri pod will use a transient
    ## emptyDir-backed storage instead.
    persistence:
      enabled: false
      size: 4Gi
      ## Set this to existing PVC name if you have one.
      existingClaim:
      storageClassName:

    shm:
      ## Set to true to enable "/dev/shm" mount.
      ## May be required by built-in Chromium.
      enabled: false
      ## If "true", will use host's shared memory dir,
      ## and if "false" â€” an emptyDir mount.
      # useHost: false
      # size: 256Mi

    image:
      repository: jitsi/jibri
      tag: stable

    breweryMuc: jibribrewery
    timeout: 90

    ## jibri XMPP user credentials:
    xmpp:
      user: jibri
      password: s3cr37

    ## recorder XMPP user credentials:
    recorder:
      user: recorder
      password: s3cr37

    livenessProbe:
      exec:
        command: ["pgrep", "java"]

    readinessProbe:
      exec:
        command: ["pgrep", "java"]

    extraEnvs: {}

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  xmpp:
    domain: meet.mylogin.space

    authDomain:
    mucDomain:
    internalMucDomain:
    guestDomain:

  extraCommonEnvs: {}

  prosody:
    enabled: true
    persistence:
      enabled: false
    server:
    extraEnvFrom:
    - secretRef:
        name: '{{ include "prosody.fullname" . }}-jicofo'
    - secretRef:
        name: '{{ include "prosody.fullname" . }}-jvb'
    - configMapRef:
        name: '{{ include "prosody.fullname" . }}-common'
    ## Uncomment this if you want to use jibri:
    # - secretRef:
    #     name: '{{ include "prosody.fullname" . }}-jibri'
    image:
      repository: jitsi/prosody
      tag: 'stable'
